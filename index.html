<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fakebook Chat</title>
<style>
  body { margin: 0; font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; display: flex; flex-direction: column; height: 100vh; color: #1c1e21; }
  body.night { background: #18191a; color: #e4e6eb; }
  header { background: #1877f2; color: white; padding: 8px 16px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
  header h1 { margin: 0; font-size: 1.4em; font-weight: 500; }
  #changeUserBtn, #nightModeBtn, #avatarPickerBtn, #changePasskeyBtn { background: #1877f2; border: 1px solid #1c2526; border-radius: 6px; padding: 6px 12px; cursor: pointer; margin-left: 8px; font-weight: 500; color: white; font-size: 0.9em; }
  #changeUserBtn:hover, #nightModeBtn:hover, #avatarPickerBtn:hover, #changePasskeyBtn:hover { background: #1659b7; }
  #messages { flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 8px; background: #fff; }
  body.night #messages { background: #242526; }
  .message { display: flex; gap: 8px; outline: none; position: relative; max-width: 80%; }
  .message.you { flex-direction: row-reverse; align-self: flex-end; }
  .avatar-container { display: flex; flex-direction: column; align-items: center; }
  .avatar { width: 36px; height: 36px; border-radius: 50%; position: relative; }
  .avatar-username { font-weight: 500; font-size: 0.85em; margin-bottom: 4px; text-align: center; }
  .presence-online::after { content: ""; position: absolute; bottom: 0; right: 0; width: 10px; height: 10px; background: #31a24c; border: 2px solid white; border-radius: 50%; }
  .presence-offline::after { content: ""; position: absolute; bottom: 0; right: 0; width: 10px; height: 10px; background: #b0b3b8; border: 2px solid white; border-radius: 50%; }
  .message-content { display: flex; flex-direction: column; }
  .bubble { background: #e7f3ff; color: #1c1e21; border-radius: 18px; padding: 8px 12px; white-space: pre-wrap; word-break: break-word; font-size: 0.95em; line-height: 1.4; position: relative; }
  body.night .bubble { background: #3a3b3c; color: #e4e6eb; }
  .message.you .bubble { background: #1877f2; color: white; }
  body.night .message.you .bubble { background: #2374e1; }
  .bubble .emoji { font-size: 1.4em; vertical-align: middle; }
  .bubble .file-preview { max-width: 200px; border-radius: 12px; margin-top: 5px; cursor: pointer; position: relative; }
  .bubble .pdf-preview { width: 100%; height: 200px; border: none; border-radius: 12px; margin-top: 5px; cursor: pointer; }
  .bubble .doc-preview { width: 100px; height: 100px; background: url('https://img.icons8.com/ios/50/000000/document.png') no-repeat center; background-size: contain; margin-top: 5px; cursor: pointer; position: relative; }
  .bubble .download-icon { position: absolute; bottom: 5px; right: 5px; width: 24px; height: 24px; background: url('https://img.icons8.com/ios/24/ffffff/download.png') no-repeat center; background-size: contain; display: none; }
  .bubble .file-preview:hover .download-icon, .bubble .pdf-preview:hover .download-icon, .bubble .doc-preview:hover .download-icon { display: block; }
  .info { font-size: 0.7em; color: #65676b; margin-top: 2px; display: none; justify-content: space-between; align-items: center; }
  .message:hover .info, .message.touched .info { display: flex; }
  body.night .info { color: #b0b3b8; }
  .actions { display: none; position: absolute; top: -28px; background: rgba(0, 0, 0, 0.7); border-radius: 20px; padding: 4px; animation: fadeIn 0.2s ease-in; }
  .message:hover .actions, .message.touched .actions { display: flex; }
  .message.you .actions { right: 8px; }
  .message:not(.you) .actions { left: 48px; }
  .actions button { background: transparent; border: none; cursor: pointer; font-size: 1em; margin: 0 4px; color: #e4e6eb; }
  .actions button:hover { color: #f02849; }
  .actions button.delete-btn::before { content: "ğŸ—‘ï¸"; }
  .actions button.edit-btn::before { content: "âœ"; }
  @keyframes fadeIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
  #typingIndicator { height: 20px; padding: 0 16px; font-style: italic; color: #65676b; display: flex; align-items: center; gap: 5px; font-size: 0.85em; }
  body.night #typingIndicator { color: #b0b3b8; }
  .typing-dots { display: inline-flex; align-items: center; }
  .typing-dots span { width: 6px; height: 6px; background: #65676b; border-radius: 50%; margin: 0 2px; animation: typing 1.2s infinite; }
  body.night .typing-dots span { background: #b0b3b8; }
  .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
  .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes typing { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }
  footer { padding: 8px 16px; background: #fff; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.1); }
  body.night footer { background: #242526; }
  #text { flex: 1; padding: 10px; font-size: 0.95em; border-radius: 20px; border: none; background: #f0f2f5; color: #1c1e21; }
  body.night #text { background: #3a3b3c; color: #e4e6eb; }
  button { cursor: pointer; border: none; background: #1877f2; color: white; border-radius: 6px; padding: 8px 12px; font-weight: 500; font-size: 0.9em; }
  button:hover { background: #1659b7; }
  #fileInput { display: none; }
  #fileBtn, #emojiBtn, #sendBtn { background: none; color: #65676b; font-size: 1.2em; padding: 8px; }
  body.night #fileBtn, body.night #emojiBtn, body.night #sendBtn { color: #b0b3b8; }
  #fileBtn:hover, #emojiBtn:hover, #sendBtn:hover { color: #1877f2; }
  body.night #fileBtn:hover, body.night #emojiBtn:hover, body.night #sendBtn:hover { color: #2374e1; }
  #emojiPicker { position: absolute; background: #fff; border: 1px solid #ddd; border-radius: 12px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); width: 300px; max-height: 200px; overflow-y: auto; padding: 10px; z-index: 10; display: none; grid-template-columns: repeat(8, 1fr); gap: 4px; }
  body.night #emojiPicker { background: #3a3b3c; border: 1px solid #4b4c4f; color: #e4e6eb; }
  #emojiPicker::-webkit-scrollbar { width: 6px; }
  #emojiPicker::-webkit-scrollbar-thumb { background: #b0b3b8; border-radius: 3px; }
  body.night #emojiPicker::-webkit-scrollbar-thumb { background: #606770; }
  #emojiPicker span { cursor: pointer; font-size: 1.4em; padding: 4px; text-align: center; }
  #emojiPicker span:hover, #emojiPicker span:focus { background: #e7f3ff; border-radius: 6px; outline: none; }
  body.night #emojiPicker span:hover, body.night #emojiPicker span:focus { background: #4b4c4f; }
  .reaction-picker { position: absolute; background: #fff; border: 1px solid #ddd; padding: 6px; border-radius: 12px; z-index: 10; display: none; flex-direction: column; gap: 6px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); animation: reactionPop 0.2s ease-out; }
  body.night .reaction-picker { background: #3a3b3c; border: 1px solid #4b4c4f; }
  .reaction-picker span { cursor: pointer; font-size: 1.4em; padding: 4px; transition: transform 0.2s; text-align: center; }
  .reaction-picker span:hover, .reaction-picker span:focus { transform: scale(1.2); outline: none; }
  @keyframes reactionPop { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
  .reactions { display: flex; flex-direction: column; gap: 4px; margin-top: 4px; font-size: 0.9em; align-items: flex-end; }
  .message:not(.you) .reactions { align-items: flex-start; }
  .reaction { background: #e7f3ff; border-radius: 12px; padding: 4px 8px; cursor: pointer; transition: transform 0.2s; display: flex; align-items: center; gap: 6px; }
  body.night .reaction { background: #4b4c4f; }
  .reaction:hover { transform: scale(1.1); }
  .reaction-users { position: absolute; background: #fff; border: 1px solid #ddd; padding: 8px; border-radius: 8px; z-index: 20; max-width: 200px; font-size: 0.8em; display: none; flex-direction: column; gap: 4px; }
  body.night .reaction-users { background: #3a3b3c; border: 1px solid #4b4c4f; color: #e4e6eb; }
  .reaction-users div { padding: 4px; border-radius: 4px; }
  .reaction-users div:hover { background: #e7f3ff; }
  body.night .reaction-users div:hover { background: #4b4c4f; }
  #modalOverlay, #avatarPickerOverlay, #passkeyOverlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 1000; }
  #modalContent, #avatarPickerModal, #passkeyModal { background: white; padding: 20px; border-radius: 12px; width: 300px; max-width: 90%; box-sizing: border-box; outline: none; }
  body.night #modalContent, body.night #avatarPickerModal, body.night #passkeyModal { background: #3a3b3c; color: #e4e6eb; }
  #modalContent h2, #avatarPickerModal h2, #passkeyModal h2 { margin: 0 0 10px; font-size: 1.2em; font-weight: 500; }
  #usernameInput, #passkeyInput, #oldPasskeyInput, #builtinPasskeyInput { width: 100%; padding: 10px; font-size: 0.95em; margin-bottom: 12px; border-radius: 6px; border: 1px solid #ddd; }
  body.night #usernameInput, body.night #passkeyInput, body.night #oldPasskeyInput, body.night #builtinPasskeyInput { background: #4b4c4f; border: 1px solid #606770; color: #e4e6eb; }
  #saveProfileBtn, #savePasskeyBtn, #resetPasskeyBtn, #closeProfileBtn, #closePasskeyBtn { width: 100%; padding: 10px; font-weight: 500; }
  #closeProfileBtn, #closePasskeyBtn { background: #f02849; margin-top: 10px; }
  .avatar-option { width: 48px; height: 48px; border-radius: 50%; margin: 4px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s; }
  .avatar-option.selected { border-color: #1877f2; }
  .avatar-option:hover, .avatar-option:focus { border-color: #1659b7; outline: none; }
  #avatarOptions { max-height: 200px; overflow-y: auto; display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; padding: 10px; }
  #avatarOptions::-webkit-scrollbar { width: 6px; }
  #avatarOptions::-webkit-scrollbar-thumb { background: #b0b3b8; border-radius: 3px; }
  body.night #avatarOptions::-webkit-scrollbar-thumb { background: #606770; }
  #welcomeMessage { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.8em; font-weight: bold; color: #1877f2; text-align: center; animation: fadeOut 3s forwards; z-index: 1000; }
  #chatContainer { display: none; flex-direction: column; height: 100vh; }
  @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; display: none; } }
</style>
</head>
<body>

<div id="passkeyOverlay" role="dialog" aria-modal="true" aria-labelledby="passkeyTitle">
  <div id="passkeyModal" tabindex="0">
    <h2 id="passkeyTitle">Set Your Passkey</h2>
    <input type="password" id="passkeyInput" aria-required="true" aria-describedby="passkeyTitle" placeholder="Enter your passkey" />
    <input type="password" id="oldPasskeyInput" aria-required="true" aria-describedby="passkeyTitle" placeholder="Enter reset code" style="display: none;" />
    <input type="password" id="builtinPasskeyInput" aria-required="true" aria-describedby="passkeyTitle" placeholder="Enter built-in passkey" style="display: none;" />
    <button id="savePasskeyBtn">Submit</button>
    <button id="resetPasskeyBtn" style="background: #f02849; margin-top: 10px;">Reset Passkey</button>
    <button id="closePasskeyBtn" style="background: #f02849; margin-top: 10px;">Close</button>
    <div id="passkeyError" style="color: red; font-size: 0.8em; margin-top: 10px; display: none;"></div>
  </div>
</div>

<div id="welcomeMessage" style="display: none;">Welcome to Fakebook</div>

<div id="chatContainer">
  <header>
    <h1>Fakebook Chat</h1>
    <div>
      <button id="avatarPickerBtn" title="Pick Avatar" aria-label="Pick Avatar">Pick Avatar</button>
      <button id="changeUserBtn" title="Change Username" aria-label="Change Username">Change User Name</button>
      <button id="changePasskeyBtn" title="Change Passkey" aria-label="Change Passkey">Change Passkey</button>
      <button id="nightModeBtn" title="Toggle Night Mode" aria-label="Toggle Night Mode">ğŸŒ”</button>
    </div>
  </header>
  <div id="messages" tabindex="0" aria-live="polite" aria-label="Chat messages"></div>
  <div id="typingIndicator" aria-live="polite" aria-atomic="true"></div>
  <footer>
    <button id="fileBtn" title="Send File" aria-label="Send File">ğŸ”—</button>
    <input type="file" id="fileInput" aria-label="File input" accept="image/jpeg,image/png,image/gif,image/webp,image/bmp,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
    <button id="emojiBtn" title="Emoji Picker" aria-label="Emoji Picker">ğŸ˜Š</button>
    <input type="text" id="text" placeholder="Type a message..." autocomplete="off" aria-label="Message input" />
    <button id="sendBtn" title="Send Message" aria-label="Send Message">â¤</button>
  </footer>
</div>

<div id="emojiPicker" role="listbox" aria-label="Emoji picker"></div>

<div id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div id="modalContent" tabindex="0">
    <h2 id="modalTitle">Enter Username</h2>
    <input type="text" id="usernameInput" aria-required="true" aria-describedby="modalTitle" placeholder="Enter your username" />
    <div id="usernameError" style="color: red; font-size: 0.8em; margin-top: 10px; display: none;"></div>
    <button id="saveProfileBtn">Save</button>
    <button id="closeProfileBtn">Close</button>
  </div>
</div>

<div id="avatarPickerOverlay" role="dialog" aria-modal="true" aria-labelledby="avatarPickerTitle">
  <div id="avatarPickerModal" tabindex="0"></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getDatabase, ref, push, onChildAdded, onChildChanged, onChildRemoved,
    get, set, remove, onValue, onDisconnect, update
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

  import {
    getAuth,
    signInAnonymously,
    onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCx_glObBqdqtOs64JhV3fyJW-q9DOqbl0",
    authDomain: "live-chat-app-5ea98.firebaseapp.com",
    databaseURL: "https://live-chat-app-5ea98-default-rtdb.firebaseio.com",
    projectId: "live-chat-app-5ea98",
    storageBucket: "live-chat-app-5ea98.appspot.com",
    messagingSenderId: "58710835031",
    appId: "1:58710835031:web:9248de0eba59c09c0fc812"
  };

  let app, db, auth, messagesRef, typingRef, presenceRef, connectedRef, usersRef;

  try {
    app = initializeApp(firebaseConfig);
    db = getDatabase(app);
    auth = getAuth(app);

    messagesRef = ref(db, "messages");
    typingRef = ref(db, "typing");
    presenceRef = ref(db, "presence");
    connectedRef = ref(db, ".info/connected");
    usersRef = ref(db, "users");
  } catch (error) {
    const div = document.createElement("div");
    div.textContent = "Unable to connect to the server. Please check your internet connection.";
    div.style.color = "red";
    div.style.padding = "20px";
    document.body.prepend(div);
  }

  signInAnonymously(auth).catch(() => {});

  let userId = null;

  onAuthStateChanged(auth, (user) => {
    if (user) {
      userId = user.uid;
    }
  });

  const textInput = document.getElementById("text");
  const sendBtn = document.getElementById("sendBtn");
  const fileInput = document.getElementById("fileInput");
  const fileBtn = document.getElementById("fileBtn");
  const emojiBtn = document.getElementById("emojiBtn");
  const emojiPicker = document.getElementById("emojiPicker");
  const messagesDiv = document.getElementById("messages");
  const nightModeBtn = document.getElementById("nightModeBtn");
  const changeUserBtn = document.getElementById("changeUserBtn");
  const changePasskeyBtn = document.getElementById("changePasskeyBtn");
  const typingIndicator = document.getElementById("typingIndicator");
  const modalOverlay = document.getElementById("modalOverlay");
  const usernameInput = document.getElementById("usernameInput");
  const usernameError = document.getElementById("usernameError");
  const saveProfileBtn = document.getElementById("saveProfileBtn");
  const closeProfileBtn = document.getElementById("closeProfileBtn");
  const avatarPickerOverlay = document.getElementById("avatarPickerOverlay");
  const avatarPickerModal = document.getElementById("avatarPickerModal");
  const avatarPickerBtn = document.getElementById("avatarPickerBtn");
  const passkeyOverlay = document.getElementById("passkeyOverlay");
  const passkeyModal = document.getElementById("passkeyModal");
  const passkeyInput = document.getElementById("passkeyInput");
  const oldPasskeyInput = document.getElementById("oldPasskeyInput");
  const builtinPasskeyInput = document.getElementById("builtinPasskeyInput");
  const savePasskeyBtn = document.getElementById("savePasskeyBtn");
  const resetPasskeyBtn = document.getElementById("resetPasskeyBtn");
  const closePasskeyBtn = document.getElementById("closePasskeyBtn");
  const passkeyError = document.getElementById("passkeyError");
  const welcomeMessage = document.getElementById("welcomeMessage");
  const chatContainer = document.getElementById("chatContainer");

  const BUILT_IN_RESET_PASSKEY = "DarkChat";
  const maleAvatars = Array.from({ length: 100 }, (_, i) => `https://randomuser.me/api/portraits/men/${i + 1}.jpg`);
  const emojis = [
    "ğŸ˜€","ğŸ˜ƒ","ğŸ˜„","ğŸ˜","ğŸ˜†","ğŸ˜…","ğŸ˜‚","ğŸ¤£","ğŸ˜Š","ğŸ˜‡","ğŸ™‚","ğŸ™ƒ","ğŸ˜‰","ğŸ˜Œ","ğŸ˜","ğŸ¥°","ğŸ˜˜","ğŸ˜—","ğŸ˜™","ğŸ˜š",
    "ğŸ˜‹","ğŸ˜›","ğŸ˜","ğŸ˜œ","ğŸ¤ª","ğŸ¤¨","ğŸ§","ğŸ¤“","ğŸ˜","ğŸ¥³","ğŸ¤—","ğŸ¤”","ğŸ¤­","ğŸ¤«","ğŸ¤¥","ğŸ˜¶","ğŸ˜","ğŸ˜‘","ğŸ˜¬","ğŸ™„",
    "ğŸ˜","ğŸ˜£","ğŸ˜¥","ğŸ˜®","ğŸ¤","ğŸ˜¯","ğŸ˜ª","ğŸ˜«","ğŸ¥±","ğŸ˜´","ğŸ˜Œ","ğŸ˜”","ğŸ˜•","ğŸ™ƒ","ğŸ˜¢","ğŸ˜­","ğŸ˜¤","ğŸ˜ ","ğŸ˜¡","ğŸ¤¬",
    "ğŸ¤¯","ğŸ˜³","ğŸ¥µ","ğŸ¥¶","ğŸ˜±","ğŸ˜¨","ğŸ˜°","ğŸ˜¥","ğŸ˜“","ğŸ¤¤","ğŸ˜´","ğŸ˜µ","ğŸ¤","ğŸ¥´","ğŸ¤¢","ğŸ¤®","ğŸ¤§","ğŸ˜·","ğŸ¤’","ğŸ¤•",
    "ğŸ¤‘","ğŸ¤ ","ğŸ˜ˆ","ğŸ‘¿","ğŸ‘¹","ğŸ‘º","ğŸ’€","ğŸ‘»","ğŸ‘½","ğŸ¤–","ğŸ’©","ğŸ˜º","ğŸ˜¸","ğŸ˜¹","ğŸ˜»","ğŸ˜¼","ğŸ˜½","ğŸ™€","ğŸ˜¿","ğŸ˜¾",
    "ğŸ‘‹","ğŸ¤š","ğŸ–","âœ‹","ğŸ––","ğŸ‘Œ","ğŸ¤Œ","ğŸ¤","âœŒ","ğŸ¤","ğŸ¤Ÿ","ğŸ¤˜","ğŸ¤™","ğŸ‘ˆ","ğŸ‘‰","ğŸ‘†","ğŸ–•","ğŸ‘‡","â˜","ğŸ‘",
    "ğŸ‘","âœŠ","ğŸ‘Š","ğŸ¤›","ğŸ¤œ","ğŸ‘","ğŸ™Œ","ğŸ‘","ğŸ¤²","ğŸ¤","ğŸ™","âœ","ğŸ’…","ğŸ¤³","ğŸ’ª","ğŸ¦¾","ğŸ¦µ","ğŸ¦¿","ğŸ¦¶"
  ];
  const reactionEmojis = ["ğŸ‘", "â¤ï¸", "ğŸ˜‚", "ğŸ˜®", "ğŸ˜¢", "ğŸ˜¡"];

  let currentUser = null;
  let typingTimeout = null;
  let isTyping = false;
  let messagesCache = [];
  let presenceMap = new Map();
  let selectedAvatarUrl = null;
  const usersMap = new Map();
  let isScrolledToBottom = true;
  let isPasskeySet = false;
  let isPasskeyVerified = false;
  let sessionVerified = false;

  function saveUserToLocal(user) { try { localStorage.setItem("quickchat-user", JSON.stringify(user)); } catch {} }
  function loadUserFromLocal() { try { const s = localStorage.getItem("quickchat-user"); return s ? JSON.parse(s) : null; } catch { return null; } }
  function saveNightMode(enabled) { try { localStorage.setItem("quickchat-nightmode", enabled ? "1" : "0"); } catch {} }
  function loadNightMode() { try { return localStorage.getItem("quickchat-nightmode") === "1"; } catch { return false; } }
  function savePasskeyToLocal(passkey) { try { localStorage.setItem("quickchat-passkey", passkey); } catch {} }
  function loadPasskeyFromLocal() { try { return localStorage.getItem("quickchat-passkey"); } catch { return null; } }
  function saveSessionVerified() { try { sessionStorage.setItem("quickchat-session-verified", "true"); } catch {} }
  function loadSessionVerified() { try { return sessionStorage.getItem("quickchat-session-verified") === "true"; } catch { return false; } }

  function escapeHTML(str) {
    if (!str) return "";
    return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m]);
  }

  function formatTime(ts) {
    try { return new Date(ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }); }
    catch { return "??:??"; }
  }

  function hashCode(str) {
    let h = 0;
    for (let i = 0; i < str.length; i++) h = ((h << 5) - h) + str.charCodeAt(i) | 0;
    return h;
  }

  function getAvatarForUser(user) {
    if (user.avatar) return user.avatar;
    return maleAvatars[Math.abs(hashCode((user.username || "") + (userId || ""))) % maleAvatars.length];
  }

  function styleEmojis(text) {
    return text.replace(/[\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu, '<span class="emoji">$&</span>');
  }

  function makeLinksClickable(text) {
    return text.replace(/(https?:\/\/[^\s<>"']+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color:inherit;text-decoration:underline;">$1</a>');
  }

  function cacheUserInfo(msg) {
    if (msg?.userId && msg?.username) usersMap.set(msg.userId, { username: msg.username, avatar: msg.avatar || "" });
  }

  function renderMessage(msg) {
    const div = document.createElement("div");
    div.className = "message " + (msg.userId === userId ? "you" : "");
    div.dataset.messageId = msg.id;
    div.setAttribute("tabindex", "0");
    div.setAttribute("role", "article");
    div.setAttribute("aria-label", `${msg.username || "User"} said: ${msg.text || msg.fileName || "file"}`);

    const avatarContainer = document.createElement("div");
    avatarContainer.className = "avatar-container";

    const avatarUsername = document.createElement("div");
    avatarUsername.className = "avatar-username";
    avatarUsername.textContent = msg.username || "User";
    avatarContainer.appendChild(avatarUsername);

    const avatarWrapper = document.createElement("div");
    avatarWrapper.className = "avatar";
    const presence = presenceMap.get(msg.userId) === "online" ? "presence-online" : "presence-offline";
    avatarWrapper.classList.add(presence);

    const img = document.createElement("img");
    img.src = msg.avatar || getAvatarForUser(msg);
    img.alt = `${msg.username || "User"} avatar`;
    img.width = 36;
    img.height = 36;
    img.style.borderRadius = "50%";
    avatarWrapper.appendChild(img);
    avatarContainer.appendChild(avatarWrapper);

    const content = document.createElement("div");
    content.className = "message-content";

    const bubble = document.createElement("div");
    bubble.className = "bubble";

    if (msg.fileUrl) {
      const ext = (msg.fileName || "").split('.').pop().toLowerCase();
      let preview;
      if (["jpg","jpeg","png","gif","webp","bmp"].includes(ext)) {
        preview = document.createElement("img");
        preview.src = msg.fileUrl;
        preview.className = "file-preview";
        preview.alt = msg.fileName || "image";
      } else if (ext === "pdf") {
        preview = document.createElement("iframe");
        preview.src = msg.fileUrl + "#toolbar=0";
        preview.className = "pdf-preview";
      } else if (["doc","docx"].includes(ext)) {
        preview = document.createElement("div");
        preview.className = "doc-preview";
      }
      if (preview) {
        const a = document.createElement("a");
        a.href = msg.fileUrl;
        a.download = msg.fileName || "file";
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.appendChild(preview);
        bubble.appendChild(a);
      }
    } else {
      bubble.innerHTML = styleEmojis(makeLinksClickable(escapeHTML(msg.text || ""))).replace(/\n/g, "<br>");
    }

    content.appendChild(bubble);

    const info = document.createElement("div");
    info.className = "info";
    info.innerHTML = `<span>${formatTime(msg.timestamp)}</span>`;

    const actions = document.createElement("div");
    actions.className = "actions";

    if (msg.userId === userId) {
      const del = document.createElement("button");
      del.className = "delete-btn";
      del.title = "Delete";
      del.addEventListener("click", () => deleteMessage(msg.id));
      actions.appendChild(del);

      const edit = document.createElement("button");
      edit.className = "edit-btn";
      edit.title = "Edit";
      edit.addEventListener("click", () => editMessage(msg));
      actions.appendChild(edit);
    }

    const react = document.createElement("button");
    react.className = "react-btn";
    react.title = "React";
    react.textContent = "ğŸ‘";
    react.addEventListener("click", e => toggleReactionPicker(msg.id, e.target));
    actions.appendChild(react);

    info.appendChild(actions);
    content.appendChild(info);

    const reactionsDiv = document.createElement("div");
    reactionsDiv.className = "reactions";
    if (msg.reactions) {
      Object.entries(msg.reactions).forEach(([emoji, users]) => {
        const span = document.createElement("span");
        span.className = "reaction";
        span.textContent = `${emoji} ${users.length}`;
        span.addEventListener("click", e => showReactionUsers(emoji, users, e.target));
        reactionsDiv.appendChild(span);
      });
    }
    content.appendChild(reactionsDiv);

    div.appendChild(avatarContainer);
    div.appendChild(content);
    return div;
  }

  function showReactionUsers(emoji, users, el) {
    let list = document.querySelector(".reaction-users");
    if (list) list.remove();

    list = document.createElement("div");
    list.className = "reaction-users";
    list.innerHTML = `<div>${emoji} ${users.length}</div>`;
    users.forEach(uid => {
      const u = usersMap.get(uid);
      if (u) list.innerHTML += `<div>${u.username}</div>`;
    });
    el.parentElement.appendChild(list);
  }

  function updateUserMessages(uid, name) {
    messagesCache.forEach(m => {
      if (m.userId === uid) {
        m.username = name;
        const el = messagesDiv.querySelector(`[data-message-id="${m.id}"]`);
        if (el) el.replaceWith(renderMessage(m));
      }
    });
    if (usersMap.has(uid)) usersMap.get(uid).username = name;
  }

  function updateUserAvatars(uid, url) {
    messagesCache.forEach(m => {
      if (m.userId === uid) {
        m.avatar = url;
        const el = messagesDiv.querySelector(`[data-message-id="${m.id}"]`);
        if (el) el.replaceWith(renderMessage(m));
      }
    });
    if (usersMap.has(uid)) usersMap.get(uid).avatar = url;
  }

  function renderAllMessagesPresence() {
    messagesDiv.querySelectorAll(".avatar").forEach(av => {
      const uid = [...usersMap.entries()].find(([_,u]) => av.parentElement.textContent.includes(u.username))?.[0];
      if (uid) {
        av.classList.remove("presence-online", "presence-offline");
        av.classList.add(presenceMap.get(uid) === "online" ? "presence-online" : "presence-offline");
      }
    });
  }

  function addMessage(msg) {
    cacheUserInfo(msg);
    messagesCache.push(msg);
    messagesDiv.appendChild(renderMessage(msg));
    if (isScrolledToBottom) messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  async function cleanupOldMessages() {
    const cutoff = Date.now() - 3 * 86400000;
    const snap = await get(messagesRef);
    const data = snap.val() || {};
    for (const [k,v] of Object.entries(data)) {
      if (v.timestamp < cutoff) await remove(ref(db, `messages/${k}`));
    }
  }

  async function sendMessage(text, fileUrl = null, fileName = null) {
    if ((!text && !fileUrl) || !userId) return;
    if (!currentUser || !isPasskeyVerified) {
      passkeyError.textContent = "Please complete the setup process.";
      passkeyError.style.display = "block";
      openPasskeyModal(isPasskeySet ? "verify" : "set");
      return;
    }
    try {
      await push(messagesRef, {
        text: text || "",
        fileUrl: fileUrl || null,
        fileName: fileName || null,
        timestamp: Date.now(),
        userId,
        username: currentUser.username,
        avatar: selectedAvatarUrl
      });
      textInput.value = "";
      stopTyping();
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    } catch (e) {
      passkeyError.textContent = "Failed to send message";
      passkeyError.style.display = "block";
    }
  }

  async function deleteMessage(id) {
    if (!userId) return;
    const msg = messagesCache.find(m => m.id === id);
    if (!msg || msg.userId !== userId) return;
    if (!confirm("Delete this message?")) return;
    try {
      await remove(ref(db, `messages/${id}`));
      messagesCache = messagesCache.filter(m => m.id !== id);
    } catch {}
  }

  async function editMessage(msg) {
    if (!userId || !msg.text) return;
    const txt = prompt("Edit:", msg.text);
    if (!txt || txt.trim() === msg.text) return;
    try {
      await update(ref(db, `messages/${msg.id}`), { text: txt.trim() });
    } catch {}
  }

  async function addReaction(id, emoji) {
    if (!userId) return;
    try {
      const r = ref(db, `messages/${id}/reactions`);
      const s = await get(r);
      let rx = s.val() || {};
      const pair = Object.entries(rx).find(([,u]) => u.includes(userId));
      if (pair && pair[0] === emoji) {
        rx[pair[0]] = rx[pair[0]].filter(u => u !== userId);
        if (!rx[pair[0]].length) delete rx[pair[0]];
      } else {
        if (pair) {
          rx[pair[0]] = rx[pair[0]].filter(u => u !== userId);
          if (!rx[pair[0]].length) delete rx[pair[0]];
        }
        if (!rx[emoji]) rx[emoji] = [];
        if (!rx[emoji].includes(userId)) rx[emoji].push(userId);
      }
      await set(r, rx);
    } catch {}
  }

  function startTyping() {
    if (isTyping || !userId) return;
    isTyping = true;
    set(ref(db, `typing/${userId}`), true);
    typingTimeout = setTimeout(stopTyping, 3000);
  }

  function stopTyping() {
    if (!isTyping || !userId) return;
    isTyping = false;
    remove(ref(db, `typing/${userId}`));
    if (typingTimeout) clearTimeout(typingTimeout);
    textInput.placeholder = "Type a message...";
  }

  function setupTypingListener() {
    onValue(typingRef, snap => {
      const typing = [];
      snap.forEach(c => {
        if (c.key !== userId && c.val() && presenceMap.get(c.key) === "online") typing.push(c.key);
      });
      if (!typing.length) {
        typingIndicator.innerHTML = "";
        return;
      }
      const names = typing.map(u => usersMap.get(u)?.username).filter(Boolean);
      const dots = '<span class="typing-dots"><span></span><span></span><span></span></span>';
      typingIndicator.innerHTML = names.length === 1 ? `${names[0]} is typing ${dots}` :
                                  names.length === 2 ? `${names[0]} and ${names[1]} are typing ${dots}` :
                                  `${names[0]}, ${names[1]} and others are typing ${dots}`;
    });
  }

  function setupMessageListener() {
    onChildAdded(messagesRef, snap => {
      const m = snap.val();
      m.id = snap.key;
      addMessage(m);
    });
    onChildChanged(messagesRef, snap => {
      const m = snap.val();
      m.id = snap.key;
      const i = messagesCache.findIndex(x => x.id === m.id);
      if (i !== -1) {
        messagesCache[i] = m;
        const el = messagesDiv.querySelector(`[data-message-id="${m.id}"]`);
        if (el) el.replaceWith(renderMessage(m));
      }
    });
    onChildRemoved(messagesRef, snap => {
      const id = snap.key;
      messagesCache = messagesCache.filter(m => m.id !== id);
      const el = messagesDiv.querySelector(`[data-message-id="${id}"]`);
      if (el) el.remove();
    });
  }

  function setupPresence() {
    if (!userId) return;
    const pRef = ref(db, `presence/${userId}`);
    const tRef = ref(db, `typing/${userId}`);
    onValue(connectedRef, s => {
      if (s.val()) {
        set(pRef, { state: "online", lastChanged: Date.now() });
        onDisconnect(pRef).set({ state: "offline", lastChanged: Date.now() });
        onDisconnect(tRef).remove();
      }
    });
    onValue(presenceRef, s => {
      presenceMap.clear();
      s.forEach(c => presenceMap.set(c.key, c.val()?.state));
      renderAllMessagesPresence();
    });
  }

  function setupUserListener() {
    onValue(usersRef, s => {
      s.forEach(c => {
        const u = c.val();
        if (c.key !== userId) {
          if (usersMap.get(c.key)?.username !== u.username) updateUserMessages(c.key, u.username);
          if (usersMap.get(c.key)?.avatar !== u.avatar) updateUserAvatars(c.key, u.avatar);
        }
      });
    });
  }

  function openProfileModal() {
    modalOverlay.style.display = "flex";
    usernameInput.value = currentUser?.username || "";
    usernameError.style.display = "none";
    usernameInput.focus();
  }

  function openPasskeyModal(mode = "set") {
    passkeyOverlay.style.display = "flex";
    passkeyInput.value = "";
    oldPasskeyInput.value = "";
    builtinPasskeyInput.value = "";
    passkeyError.style.display = "none";

    const h2 = passkeyModal.querySelector("h2");
    if (mode === "set") {
      h2.textContent = "Set Your Passkey";
      oldPasskeyInput.style.display = "none";
      builtinPasskeyInput.style.display = "block";
      builtinPasskeyInput.placeholder = "Enter built-in passkey";
      resetPasskeyBtn.style.display = "none";
    } else if (mode === "reset") {
      h2.textContent = "Reset Passkey";
      oldPasskeyInput.style.display = "none";
      builtinPasskeyInput.style.display = "block";
      builtinPasskeyInput.placeholder = "Enter built-in passkey";
      resetPasskeyBtn.style.display = "none";
    } else {
      h2.textContent = "Verify Passkey";
      oldPasskeyInput.style.display = "none";
      builtinPasskeyInput.style.display = "none";
      resetPasskeyBtn.style.display = "block";
    }
    passkeyInput.focus();
  }

  async function checkUsernameUnique(name) {
    const s = await get(usersRef);
    const users = s.val() || {};
    return !Object.values(users).some(u => u.username === name && u.userId !== userId);
  }

  async function verifyPasskey(uid, pk) {
    const s = await get(ref(db, `users/${uid}`));
    const d = s.val();
    return d && d.passkey === pk;
  }

  async function savePasskey(uid, pk, reset = false, builtIn = null) {
    if (pk.length < 4) {
      passkeyError.textContent = "Passkey must be at least 4 characters.";
      passkeyError.style.display = "block";
      return false;
    }
    if (reset && builtIn !== BUILT_IN_RESET_PASSKEY) {
      passkeyError.textContent = "Incorrect reset code.";
      passkeyError.style.display = "block";
      return false;
    }
    try {
      await update(ref(db, `users/${uid}`), { passkey: pk });
      savePasskeyToLocal(pk);
      isPasskeySet = true;
      return true;
    } catch {
      passkeyError.textContent = "Failed to save passkey.";
      passkeyError.style.display = "block";
      return false;
    }
  }

  async function verifyUserPasskey(uid, pk) {
    const valid = await verifyPasskey(uid, pk);
    if (!valid) {
      passkeyError.textContent = "Invalid passkey.";
      passkeyError.style.display = "block";
    }
    return valid;
  }

  saveProfileBtn.addEventListener("click", async () => {
    const val = usernameInput.value.trim();
    if (val.length < 2) {
      usernameError.textContent = "Username must be at least 2 characters.";
      usernameError.style.display = "block";
      usernameInput.focus();
      return;
    }
    if (!(await checkUsernameUnique(val))) {
      usernameError.textContent = "Username taken.";
      usernameError.style.display = "block";
      usernameInput.focus();
      return;
    }
    try {
      userId = userId || 'guest_' + Date.now().toString(36);
      const old = currentUser?.username;
      currentUser = { username: val, avatar: currentUser?.avatar, passkey: currentUser?.passkey };
      selectedAvatarUrl = currentUser.avatar || maleAvatars[hashCode(val + userId) % maleAvatars.length];
      currentUser.avatar = selectedAvatarUrl;
      await set(ref(db, `users/${userId}`), currentUser);
      saveUserToLocal(currentUser);
      usersMap.set(userId, { username: val, avatar: selectedAvatarUrl });
      if (old && old !== val) updateUserMessages(userId, val);
      modalOverlay.style.display = "none";
      if (!isPasskeySet) openPasskeyModal("set");
      else openPasskeyModal("verify");
    } catch (e) {
      usernameError.textContent = "Failed to save profile.";
      usernameError.style.display = "block";
    }
  });

  usernameInput.addEventListener("keydown", e => { if (e.key === "Enter") { e.preventDefault(); saveProfileBtn.click(); } });
  closeProfileBtn.addEventListener("click", () => { modalOverlay.style.display = "none"; if (!currentUser) openProfileModal(); });
  closePasskeyBtn.addEventListener("click", () => { passkeyOverlay.style.display = "none"; });
  savePasskeyBtn.addEventListener("click", async () => {
    const pk = passkeyInput.value.trim();
    const bi = builtinPasskeyInput.value.trim();
    const mode = passkeyModal.querySelector("h2").textContent;
    if (!currentUser || !userId) {
      passkeyError.textContent = "Set up profile first.";
      passkeyError.style.display = "block";
      return;
    }
    if (mode === "Set Your Passkey") {
      if (await savePasskey(userId, pk, false, bi)) {
        passkeyOverlay.style.display = "none";
        openPasskeyModal("verify");
      }
    } else if (mode === "Reset Passkey") {
      if (await savePasskey(userId, pk, true, bi)) {
        passkeyOverlay.style.display = "none";
        isPasskeyVerified = true;
        sessionVerified = true;
        saveSessionVerified();
        showChatInterface();
      }
    } else if (mode === "Verify Passkey") {
      if (await verifyUserPasskey(userId, pk)) {
        savePasskeyToLocal(pk);
        isPasskeyVerified = true;
        sessionVerified = true;
        saveSessionVerified();
        passkeyOverlay.style.display = "none";
        showChatInterface();
      }
    }
  });
  resetPasskeyBtn.addEventListener("click", () => openPasskeyModal("reset"));
  changePasskeyBtn.addEventListener("click", () => openPasskeyModal("reset"));

  function showChatInterface() {
    welcomeMessage.style.display = "block";
    setTimeout(() => {
      welcomeMessage.style.display = "none";
      chatContainer.style.display = "flex";
      setupTypingListener();
      setupMessageListener();
      setupUserListener();
      setupPresence();
      setTimeout(() => messagesDiv.scrollTop = messagesDiv.scrollHeight, 0);
      cleanupOldMessages();
    }, 3000);
  }

  function openAvatarPicker() {
    avatarPickerModal.innerHTML = `
      <h2 id="avatarPickerTitle">Choose Avatar</h2>
      <div id="avatarOptions"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="saveAvatarBtn">Save</button>
        <button id="closeAvatarBtn">Close</button>
      </div>
    `;
    const opts = avatarPickerModal.querySelector("#avatarOptions");
    maleAvatars.forEach(u => {
      const i = document.createElement("img");
      i.src = u;
      i.className = "avatar-option";
      if (u === selectedAvatarUrl) i.classList.add("selected");
      i.onclick = () => {
        opts.querySelectorAll(".avatar-option").forEach(o => o.classList.remove("selected"));
        i.classList.add("selected");
        selectedAvatarUrl = u;
      };
      opts.appendChild(i);
    });
    avatarPickerOverlay.style.display = "flex";

    document.getElementById("saveAvatarBtn").onclick = async () => {
      if (selectedAvatarUrl && currentUser) {
        currentUser.avatar = selectedAvatarUrl;
        await set(ref(db, `users/${userId}`), currentUser);
        saveUserToLocal(currentUser);
        updateUserAvatars(userId, selectedAvatarUrl);
        avatarPickerOverlay.style.display = "none";
      }
    };
    document.getElementById("closeAvatarBtn").onclick = () => avatarPickerOverlay.style.display = "none";
  }

  function toggleReactionPicker(id, btn) {
    let p = btn.parentElement.querySelector(".reaction-picker");
    if (p) return p.remove();
    p = document.createElement("div");
    p.className = "reaction-picker";
    reactionEmojis.forEach(e => {
      const s = document.createElement("span");
      s.textContent = e;
      s.onclick = () => { addReaction(id, e); p.remove(); };
      p.appendChild(s);
    });
    btn.parentElement.appendChild(p);
  }

  nightModeBtn.onclick = () => {
    document.body.classList.toggle("night");
    saveNightMode(document.body.classList.contains("night"));
  };

  changeUserBtn.onclick = openProfileModal;
  avatarPickerBtn.onclick = openAvatarPicker;

  sendBtn.onclick = () => sendMessage(textInput.value.trim());
  textInput.onkeydown = e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage(textInput.value.trim());
    } else startTyping();
  };
  textInput.oninput = () => textInput.value.trim() ? startTyping() : stopTyping();

  fileBtn.onclick = () => fileInput.click();
  fileInput.onchange = async e => {
    const f = e.target.files[0];
    if (!f) return;
    if (f.size > 5*1024*1024) {
      passkeyError.textContent = "File too large (max 5MB)";
      passkeyError.style.display = "block";
      return;
    }
    const types = ["image/jpeg","image/png","image/gif","image/webp","image/bmp","application/pdf","application/msword","application/vnd.openxmlformats-officedocument.wordprocessingml.document"];
    if (!types.includes(f.type)) {
      passkeyError.textContent = "Unsupported file type";
      passkeyError.style.display = "block";
      return;
    }
    const r = new FileReader();
    r.onload = ev => sendMessage("", ev.target.result, f.name);
    r.readAsDataURL(f);
  };

  function populateEmojiPicker() {
    emojiPicker.innerHTML = "";
    emojis.forEach(e => {
      const s = document.createElement("span");
      s.textContent = e;
      s.onclick = () => { textInput.value += e; textInput.focus(); emojiPicker.style.display = "none"; };
      emojiPicker.appendChild(s);
    });
  }
  populateEmojiPicker();

  emojiBtn.onclick = () => {
    emojiPicker.style.display = emojiPicker.style.display === "none" ? "grid" : "none";
  };

  document.onclick = e => {
    if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) emojiPicker.style.display = "none";
  };

  messagesDiv.onscroll = () => {
    isScrolledToBottom = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 10;
  };

  window.onbeforeunload = () => { if (userId) remove(ref(db, `typing/${userId}`)); };

  async function init() {
    if (loadNightMode()) document.body.classList.add("night");
    currentUser = loadUserFromLocal();
    sessionVerified = loadSessionVerified();

    if (!currentUser) {
      openProfileModal();
      return;
    }

    if (!userId) {
      await new Promise(r => {
        const u = onAuthStateChanged(auth, user => {
          if (user) { u(); r(); }
        });
        setTimeout(r, 10000);
      });
    }

    const snap = await get(ref(db, `users/${userId}`));
    const data = snap.val();

    selectedAvatarUrl = data?.avatar || maleAvatars[hashCode(currentUser.username + userId) % maleAvatars.length];
    currentUser.avatar = selectedAvatarUrl;
    currentUser.passkey = data?.passkey;
    isPasskeySet = !!data?.passkey;

    usersMap.set(userId, { username: currentUser.username, avatar: selectedAvatarUrl });

    if (sessionVerified && data?.passkey && await verifyPasskey(userId, loadPasskeyFromLocal())) {
      isPasskeyVerified = true;
      showChatInterface();
    } else {
      openPasskeyModal("verify");
    }
  }

  init();
</script>
</body>
</html>
